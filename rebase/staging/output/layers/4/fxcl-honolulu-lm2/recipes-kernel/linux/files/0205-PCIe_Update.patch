From 2ee25063704dbd32798e376328de7cb28a52f37a Mon Sep 17 00:00:00 2001
From: jthomas <jacob.thomas@windriver.com>
Date: Wed, 11 May 2016 11:36:30 +0900
Subject: [PATCH 160/170] 0205-PCIe_Update


diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c
index eeb8d63..e862727 100644
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@ -54,7 +54,11 @@
 #include "e1000.h"
 
 #define DRV_EXTRAVERSION "-k"
-extern	int	synopsys_pcie_interrupt_clear(unsigned int irq_no);
+#ifdef	WR_E1000E_WORKAROUND
+static unsigned int skip_xmit    = 0;
+static unsigned int skip_xmit_cnt= 0;
+#define	SKIP_XMIT_VAL		30
+#endif
 
 #define DRV_VERSION "2.3.2" DRV_EXTRAVERSION
 char e1000e_driver_name[] = "e1000e";
@@ -1839,7 +1843,6 @@ static irqreturn_t e1000_intr(int __always_unused irq, void *data)
 		if (!test_bit(__E1000_DOWN, &adapter->state))
 			mod_timer(&adapter->watchdog_timer, jiffies + 1);
 	}
-	synopsys_pcie_interrupt_clear(95);	/* yamano */
 	/* Reset on uncorrectable ECC error */
 	if ((icr & E1000_ICR_ECCER) && (hw->mac.type == e1000_pch_lpt)) {
 		u32 pbeccsts = er32(PBECCSTS);
@@ -5527,7 +5530,25 @@ static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
 	/* need: count + 2 desc gap to keep tail from touching
 	 * head, otherwise try next time
 	 */
+#ifdef	WR_E1000E_WORKAROUND
+	if ( skip_xmit ) {
+		if ( skip_xmit_cnt != 0 ) {
+			if ( skip_xmit_cnt > skip_xmit )
+				skip_xmit_cnt=0;
+			else
+				skip_xmit_cnt++;
+			return NETDEV_TX_BUSY;
+		} else {
+			skip_xmit_cnt++;
+		}
+
+	} else {
+		skip_xmit_cnt=0;
+	}
+	if (e1000_maybe_stop_tx(tx_ring, count + 220))
+#else
 	if (e1000_maybe_stop_tx(tx_ring, count + 2))
+#endif  /* WR_E1000E_WORKAROUND */
 		return NETDEV_TX_BUSY;
 
 	if (vlan_tx_tag_present(skb)) {
@@ -5708,6 +5729,13 @@ static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
 	if (netif_running(netdev))
 		e1000e_down(adapter);
 
+#ifdef	WR_E1000E_WORKAROUND
+	if ( netdev->mtu > 1500 ){
+		skip_xmit = SKIP_XMIT_VAL;
+	} else {
+		skip_xmit = 0;
+	}
+#endif	/* WR_E1000E_WORKAROUND */
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
 	 * larger slab size.
diff --git a/drivers/pci/pcie/synopsys_pcie.c b/drivers/pci/pcie/synopsys_pcie.c
index 4a2c027..868dacc 100644
--- a/drivers/pci/pcie/synopsys_pcie.c
+++ b/drivers/pci/pcie/synopsys_pcie.c
@@ -13,12 +13,6 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/module.h>
-#if 0
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_gpio.h>
-#include <linux/of_pci.h>
-#endif
 #include <linux/pci.h>
 #include <linux/pci_regs.h>
 #include <linux/platform_device.h>
@@ -29,8 +23,11 @@
 #include "synopsys_pcie.h"
 
 #undef	DEBUG_TRACE
-#undef	DEBUG_RW
-#undef	DEBUG_CALLBACK
+#undef	DEBUG_TRACE_IRQ
+#undef	DEBUG_RW1
+#undef	PCIE_IRQ_USE
+#undef	DMA_USE
+#define MEM_SIZE_1M
 
 #define	PCIE_PORT1	1
 #define	PCIE_PORT2	2
@@ -40,15 +37,16 @@
 #define	PCIE_LANE_PHY_CONF_2	2
 #define	PCIE_LANE_PHY_CONF_3	3	/* l1:p1:cont1:p0 default ! */
 
+static unsigned char   pcie_probe_end=0;
+
 struct pcie_port_info {
-	u32		io_size;
-	u32		mem_size;
-//	phys_addr_t	mem_bus_addr;
-	struct resource		cfg;			/* ohkuma */
+	u32			io_size;
+	u32			mem_size;
+	struct resource		cfg;
 	void __iomem		*va_cfg;
 	int			irq;
-	struct resource		io;			/* ohkuma */
-	struct resource		mem;			/* ohkuma */
+	struct resource		io;
+	struct resource		mem;
 };
 
 struct pcie_port {
@@ -56,13 +54,13 @@ struct pcie_port {
 	u8			controller;
 	u8			root_bus_nr;
 	void __iomem		*resetgen_base;
-	void __iomem		*pciewrap_base;		/* ohkuma */
-	void __iomem		*pciegen3_base1;	/* ohkuma */
-	void __iomem		*pciegen3_base2;	/* ohkuma */
-	void __iomem		*pciegen3_base3;	/* ohkuma */
-	struct resource		resetgen;		/* ohkuma */
-	struct resource		pciewrap;		/* ohkuma */
-	struct resource		pciegen3[3];		/* ohkuma */
+	void __iomem		*pciewrap_base;
+	void __iomem		*pciegen3_base1;
+	void __iomem		*pciegen3_base2;
+	void __iomem		*pciegen3_base3;
+	struct resource		resetgen;
+	struct resource		pciewrap;
+	struct resource		pciegen3[3];
 	spinlock_t		conf_lock;
 	void __iomem		*va_cfg;
 	struct resource		io;
@@ -73,7 +71,9 @@ struct pcie_port {
 	struct clk		*clk;
 	struct clk		*bus_clk;
 	int			irq;
-//	int			reset_gpio;
+#ifdef	PCIE_IRQ_USE
+	int			irq_pciebus;
+#endif
 };
 
 int	rc_num = 1;
@@ -83,7 +83,6 @@ int	bifur_num = 2;
 static	void __iomem	*pcie_1_reg;
 static	void __iomem	*pcie_wrap;
 
-#define IRQ_V2M_PCIE            (32 + 17)
 /*
  * CSR PCIe IP consists of Synopsys specific part and CSR
  * specific part. Only core block is a Synopsys designware part;
@@ -98,21 +97,21 @@ static u32 inline synopsys_readl(void __iomem *offset)
 {
 	u32	val;
 	val = readl(offset);
-	printk(KERN_ERR "%s : Addr=0x%8.8x Data=0x%8.8x\n", __FUNCTION__, offset, val);
+	printk(KERN_ERR "%s  : Addr=0x%8.8x Data=0x%8.8x\n", __FUNCTION__, offset, val);
 	return val;
 }
 static u32 inline synopsys_readw(void __iomem *offset)
 {
 	u32	val;
 	val = readw(offset);
-	printk(KERN_ERR "%s : Addr=0x%8.8x Data=0x%4.4x\n", __FUNCTION__, offset, val);
+	printk(KERN_ERR "%s  : Addr=0x%8.8x Data=0x%4.4x\n", __FUNCTION__, offset, val);
 	return (val & 0x0000ffff);
 }
 static u32 inline synopsys_readb(void __iomem *offset)
 {
 	u32	val;
 	val = readb(offset);
-	printk(KERN_ERR "%s : Addr=0x%8.8x Data=0x%2.2x\n", __FUNCTION__, offset, val);
+	printk(KERN_ERR "%s  : Addr=0x%8.8x Data=0x%2.2x\n", __FUNCTION__, offset, val);
 	return (val & 0x000000ff);
 }
 
@@ -157,31 +156,25 @@ static int synopsys_pcie_setup(int nr, struct pci_sys_data *sys)
 {
 	struct pcie_port *pp;
 
-//printk(KERN_ERR "# %s entry \n",__FUNCTION__);
 	pp = sys_to_pcie(sys);
 
-#ifdef	DEBUG_CALLBACK
-	dev_err(pp->dev, "##### %s : Start\n",__FUNCTION__);
+#ifdef	DEBUG_TRACE
+	dev_err(pp->dev, "%s : Start\n",__FUNCTION__);
 #endif
 
 	if (!pp) {
-		dev_err(pp->dev, "##### %s : Error End\n",__FUNCTION__);
-#ifdef	DEBUG_CALLBACK
-		dev_err(pp->dev, "##### %s : Error End\n",__FUNCTION__);
+		dev_err(pp->dev, "%s : Error End\n",__FUNCTION__);
+#ifdef	DEBUG_TRACE
+		dev_err(pp->dev, "%s : Error End\n",__FUNCTION__);
 #endif
 		return 0;
 	}
-//printk(KERN_ERR "sys->busnr :0x%x\n",sys->busnr);
-//printk(KERN_ERR "sys->mem_offset :0x%llx\n",sys->mem_offset);
-//printk(KERN_ERR "sys->io_offset :0x%llx\n",sys->io_offset);
 /* yamano resource debug */
 //	sys->mem_offset = pp->mem.start - pp->config.mem_bus_addr;
 //	pci_add_resource_offset(&sys->resources, &pp->mem, sys->mem_offset);
 //	pci_add_resource_offset(&sys->resources, &pp->config[1].mem, sys->mem_offset);
 	sys->mem_offset = 0x404000000ULL - 0x10000000ULL;
 	sys->io_offset  = 0x410000000ULL - 0x10100000ULL;
-//printk(KERN_ERR "print offset mem = 0x%llx\n",sys->mem_offset);
-//printk(KERN_ERR "print offset io = 0x%llx\n",sys->io_offset);
 	if(request_resource(&iomem_resource,&pp->config[0].io)){
 		printk(KERN_ERR " iomem io resource reqest error \n");
 	}
@@ -191,8 +184,8 @@ static int synopsys_pcie_setup(int nr, struct pci_sys_data *sys)
 	}
 	pci_add_resource_offset(&sys->resources, &pp->config[0].mem, sys->mem_offset);
 	
-#ifdef	DEBUG_CALLBACK
-	dev_err(pp->dev, "##### %s : End\n",__FUNCTION__);
+#ifdef	DEBUG_TRACE
+	dev_err(pp->dev, "%s : End\n",__FUNCTION__);
 #endif
 	return 1;
 }
@@ -200,25 +193,19 @@ static int synopsys_pcie_setup(int nr, struct pci_sys_data *sys)
 static int synopsys_pcie_link_up(struct pcie_port *pp)
 {
 	u32 val;
+	int rtn = 0;
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Start\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Start\n",__FUNCTION__);
 #endif
 	
 	val = synopsys_readl(pp->pciewrap_base + PCIE1_MISC_STAT);
-//	switch (pp->controller) {
-//		case 0: val = synopsys_readl(pp->pciewrap_base + PCIE1_MISC_STAT);
-//			   break;
-//		case 1: val = synopsys_readl(pp->pciewrap_base + PCIE2_MISC_STAT);
-//			   break;
-//		case 2: val = synopsys_readl(pp->pciewrap_base + PCIE3_MISC_STAT);
-//			   break;
-//		default: dev_err(pp->dev, "error controller\n");
-//			   break;
-//	}
-	if (val == PCIE1_MISC_STAT__GDA_PAB_DL_UP__MASK)
-		return 1;
+	if (val == PCIE1_MISC_STAT__GDA_PAB_DL_UP__MASK) 
+		rtn = 1;
 
-	return 0;
+#ifdef	DEBUG_TRACE
+	dev_err(pp->dev, "%s : End(rtn=%d)\n",__FUNCTION__, rtn);
+#endif
+	return rtn;
 }
 
 /*
@@ -340,20 +327,17 @@ static struct pci_bus *synopsys_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 	struct pcie_port *pp = sys_to_pcie(sys);
 
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Entry nr=%d bus=%d Start\n", __FUNCTION__, nr, sys->busnr);
+	dev_err(pp->dev, "%s : Entry nr=%d bus=%d Start\n", __FUNCTION__, nr, sys->busnr);
 #endif
-
 	if (pp) {
 		pp->root_bus_nr = sys->busnr;
-//dev_err(pp->dev, "%s resources=%x\n",__FUNCTION__,sys->resources);
-	
 		bus = pci_scan_root_bus(NULL, sys->busnr, &synopsys_pcie_ops, sys, &sys->resources);
 	} else {
 		bus = NULL;
 		BUG();
 	}
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Exit\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Exit\n",__FUNCTION__);
 #endif
 	return bus;
 }
@@ -361,11 +345,9 @@ static struct pci_bus *synopsys_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 static int synopsys_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	struct pcie_port *pp = sys_to_pcie(dev->bus->sysdata);
-
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Entry\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Entry(irq=%d)\n",__FUNCTION__,pp->irq);
 #endif
-	
 	return pp->irq;
 }
 
@@ -382,7 +364,7 @@ static void synopsys_pcie_assert_phy_reset(struct pcie_port *pp)
 	void __iomem *pciewrap_base = pp->pciewrap_base;
 
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Entry\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Entry\n",__FUNCTION__);
 #endif
 	
 	regVal  = synopsys_readl(pciewrap_base + PCIE_PHY_RST_CTRL);
@@ -390,7 +372,7 @@ static void synopsys_pcie_assert_phy_reset(struct pcie_port *pp)
 	synopsys_writel(pciewrap_base + PCIE_PHY_RST_CTRL, regVal);
 
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Exit\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Exit\n",__FUNCTION__);
 #endif
 }
 
@@ -400,16 +382,14 @@ static void synopsys_pcie_assert_pipe_reset(struct pcie_port *pp)
 	void __iomem *pciewrap_base = pp->pciewrap_base;
 
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Entry\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Entry\n",__FUNCTION__);
 #endif
-	
 	regVal  = synopsys_readl(pciewrap_base + PCIE_PHY_RST_CTRL);
 	regVal &= PCIE_PHY_RST_CTRL__PIPE0_RESET_N__INV_MASK;
-	regVal &= PCIE_PHY_RST_CTRL__PIPE1_RESET_N__INV_MASK;
-	regVal &= PCIE_PHY_RST_CTRL__PIPE2_RESET_N__INV_MASK;
 	synopsys_writel(pciewrap_base + PCIE_PHY_RST_CTRL, regVal);
+
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Exit\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Exit\n",__FUNCTION__);
 #endif
 }
 
@@ -419,70 +399,52 @@ static void synopsys_pcie_assert_gpex_reset(struct pcie_port *pp)
 	void __iomem *pciewrap_base = pp->pciewrap_base;
 	
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Entry\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Entry\n",__FUNCTION__);
 #endif
 	if( rc_num == 1 || ep_num == 1 || nu_num == 1 ) {
 		regVal  = synopsys_readl(pciewrap_base + PCIE1_SW_RST);
+		regVal |= PCIE1_SW_RST__PERST_N__MASK;
 		regVal &=(PCIE1_SW_RST__PAB_N__INV_MASK  &
-			      PCIE1_SW_RST__AMBA_N__INV_MASK &
-				  PCIE1_SW_RST__PBUS_N__INV_MASK &
-			      PCIE1_SW_RST__LINK_N__INV_MASK);
+			  PCIE1_SW_RST__AMBA_N__INV_MASK &
+			  PCIE1_SW_RST__PBUS_N__INV_MASK &
+			  PCIE1_SW_RST__LINK_N__INV_MASK);
 		synopsys_writel(pciewrap_base + PCIE1_SW_RST, regVal);
 	}
-	if( rc_num == 2 || ep_num == 2 || nu_num == 2 ) {
-		regVal  = synopsys_readl(pciewrap_base + PCIE2_SW_RST);
-		regVal &=(PCIE2_SW_RST__PAB_N__INV_MASK  &
-			      PCIE2_SW_RST__AMBA_N__INV_MASK &
-				  PCIE2_SW_RST__PBUS_N__INV_MASK &
-			      PCIE2_SW_RST__LINK_N__INV_MASK);
-		synopsys_writel(pciewrap_base + PCIE2_SW_RST, regVal);
-	}
-	if( rc_num == 3 || ep_num == 3 || nu_num == 3 ) {
-		regVal  = synopsys_readl(pciewrap_base + PCIE3_SW_RST);
-		regVal &=(PCIE3_SW_RST__PAB_N__INV_MASK  &
-			      PCIE3_SW_RST__AMBA_N__INV_MASK &
-				  PCIE3_SW_RST__PBUS_N__INV_MASK &
-			      PCIE3_SW_RST__LINK_N__INV_MASK);
-		synopsys_writel(pciewrap_base + PCIE3_SW_RST, regVal);
-	}
+
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "##### %s : Exit\n",__FUNCTION__);
+	dev_err(pp->dev, "%s : Exit\n",__FUNCTION__);
 #endif
 }
 
-static void synopsys_pcie_set_bootstrap(struct pcie_port *pp, int which, int ep_rc)
+#if 1	/* ADD */
+static void synopsys_pcie_ovlctl12(struct pcie_port *pp)
 {
 	u32 regVal;
-	void __iomem *pciewrap_base = pp->pciewrap_base;
-	
-	regVal = synopsys_readl(pciewrap_base + PCIE_SW_BOOTSTRAP);
-	switch (which)
-	{
-		case 1 :
-			if (ep_rc == 1)
-				regVal |= PCIE_SW_BOOTSTRAP__PCIE1_EP_RC_SEL__MASK;
-			else
-				regVal &= PCIE_SW_BOOTSTRAP__PCIE1_EP_RC_SEL__INV_MASK;
-			break;
-		case 2 :
-			if (ep_rc == 1)
-				regVal |= PCIE_SW_BOOTSTRAP__PCIE2_EP_RC_SEL__MASK;
-			else
-				regVal &= PCIE_SW_BOOTSTRAP__PCIE2_EP_RC_SEL__INV_MASK;
-			break;
-		case 3 :
-			if (ep_rc == 1)
-				regVal |= PCIE_SW_BOOTSTRAP__PCIE3_EP_RC_SEL__MASK;
-			else
-				regVal &= PCIE_SW_BOOTSTRAP__PCIE3_EP_RC_SEL__INV_MASK;
-			break;
-		default :
-			dev_err(pp->dev, "synopsys_pcie_set_bootstrap: which is %d Error\n", which);
-				break;
-	}
-	synopsys_writel(pciewrap_base + PCIE_SW_BOOTSTRAP, regVal);
-	
+	void __iomem *addr;
+#ifdef	DEBUG_TRACE
+	dev_err(pp->dev, "%s : Entry\n",__FUNCTION__);
+#endif
+	addr = ioremap_nocache(0x0409003c,4);
+	regVal = readl(addr);
+	regVal &= ~0x00000070;
+	writel(regVal, addr);
+	iounmap(addr);
+
+	addr = ioremap_nocache(0x040800e0,4);	//PCIE_PIORESA
+	writel((1<<12), addr);
+	iounmap(addr);
+
+	addr = ioremap_nocache(0x04080040,4);	//PCIE_PIODIRA
+	regVal = readl(addr);
+	regVal &= ~(1<<12);
+	writel(regVal, addr);
+	iounmap(addr);
+
+#ifdef	DEBUG_TRACE
+	dev_err(pp->dev, "%s : Exit\n",__FUNCTION__);
+#endif
 }
+#endif
 
 static void synopsys_pcie_pcie_bifur(struct pcie_port *pp, int port_sel)
 {
@@ -514,29 +476,7 @@ static void synopsys_pcie_deassert_pipe_reset(struct pcie_port *pp, int which, i
 	void __iomem *pciewrap_base = pp->pciewrap_base;
 	
 	regVal  = synopsys_readl(pciewrap_base + PCIE_PHY_RST_CTRL);
-	switch(which) {
-		case 1: 
-			if (assert == 0)
-				regVal |= PCIE_PHY_RST_CTRL__PIPE0_RESET_N__MASK;
-			else
-				regVal &= PCIE_PHY_RST_CTRL__PIPE0_RESET_N__INV_MASK;
-			break;
-		case 2: 
-			if (assert == 0)
-				regVal |= PCIE_PHY_RST_CTRL__PIPE1_RESET_N__MASK;
-			else
-				regVal &= PCIE_PHY_RST_CTRL__PIPE1_RESET_N__INV_MASK;
-				break;
-		case 3: 
-			if (assert == 0)
-				regVal |= PCIE_PHY_RST_CTRL__PIPE2_RESET_N__MASK;
-			else
-				regVal &= PCIE_PHY_RST_CTRL__PIPE2_RESET_N__INV_MASK;
-			break;
-		default:
-			dev_err(pp->dev, "synopsys_pcie_deassert_pipe_reset: which is %d Error\n",which);
-			break;
-	}
+	regVal |= PCIE_PHY_RST_CTRL__PIPE0_RESET_N__MASK;
 	synopsys_writel(pciewrap_base + PCIE_PHY_RST_CTRL, regVal);
 }
 
@@ -548,7 +488,7 @@ static	int	synopsys_pcie_pipe_ok(struct pcie_port *pp, int which)
 	
 	regVal  = synopsys_readl(pciewrap_base + PCIE_PHY_PIPE_STAT);
 	switch(which) {
-		case 1: while ((regVal &= PCIE_PHY_PIPE_STAT__PIPE0_PHYSTATUS__MASK) != 0)
+		case 1: while ((regVal & PCIE_PHY_PIPE_STAT__PIPE0_PHYSTATUS__MASK) == 0)
 		        {
 				if(timeout > 50)	
 					return -1;
@@ -587,337 +527,150 @@ static void synopsys_pcie_deassert_gpex_reset(struct pcie_port *pp, int which, i
 	u32 regVal;
 	void __iomem *pciewrap_base = pp->pciewrap_base;
 	
-	switch(which) {
-		case 1:
-			regVal  = synopsys_readl(pciewrap_base + PCIE1_SW_RST);
-			if (assert == 0) {
-				regVal |=(PCIE1_SW_RST__PAB_N__MASK  |
-					      PCIE1_SW_RST__AMBA_N__MASK |
-						  PCIE1_SW_RST__PBUS_N__MASK |
-						      PCIE1_SW_RST__LINK_N__MASK);
-			} else {
-				regVal &=(PCIE1_SW_RST__PAB_N__MASK  &
-						      PCIE1_SW_RST__AMBA_N__MASK &
-							  PCIE1_SW_RST__PBUS_N__MASK &
-						      PCIE1_SW_RST__LINK_N__MASK);
-			}
-//			dev_err(pp->dev, "synopsys_pcie_deassert_gpex_reset:  %d \n",regVal);
-			synopsys_writel(pciewrap_base + PCIE1_SW_RST, regVal);
-		        break;
-		case 2:
-			regVal  = synopsys_readl(pciewrap_base + PCIE2_SW_RST);
-			if (assert == 0) {
-				regVal |=(PCIE2_SW_RST__PAB_N__MASK  |
-					      PCIE2_SW_RST__AMBA_N__MASK |
-						  PCIE2_SW_RST__PBUS_N__MASK |
-					      PCIE2_SW_RST__LINK_N__MASK);
-			} else {
-				regVal &=(PCIE2_SW_RST__PAB_N__MASK  &
-					      PCIE2_SW_RST__AMBA_N__MASK &
-						  PCIE2_SW_RST__PBUS_N__MASK &
-					      PCIE2_SW_RST__LINK_N__MASK);
-			}
-			synopsys_writel(pciewrap_base + PCIE2_SW_RST, regVal);
-		        break;
-		case 3: 
-			regVal  = synopsys_readl(pciewrap_base + PCIE3_SW_RST);
-			if (assert == 0) {
-				regVal |=(PCIE3_SW_RST__PAB_N__MASK  |
-					      PCIE3_SW_RST__AMBA_N__MASK |
-						  PCIE3_SW_RST__PBUS_N__MASK |
-						      PCIE3_SW_RST__LINK_N__MASK);
-			} else {
-				regVal &=(PCIE3_SW_RST__PAB_N__MASK  &
-					      PCIE3_SW_RST__AMBA_N__MASK &
-						  PCIE3_SW_RST__PBUS_N__MASK &
-					      PCIE3_SW_RST__LINK_N__MASK);
-			}
-			synopsys_writel(pciewrap_base + PCIE3_SW_RST, regVal);
-		        break;
-		default:
-			dev_err(pp->dev, "synopsys_pcie_deassert_gpex_reset: which is %d Error\n",which);
-			break;
-	}
+	regVal  = synopsys_readl(pciewrap_base + PCIE1_SW_RST);
+	regVal &= ~0x00000010;
+	regVal |= (0x00000001|0x00000002|0x00000004|0x00000008);
+	synopsys_writel(pciewrap_base + PCIE1_SW_RST, regVal);
 }
-#if 0
-static void synopsys_pcie_gpexd_core_clk_ratio(struct pcie_port *pp, int which)
+
+static void synopsys_pcie_AxiToPexInit(struct pcie_port *pp)
 {
-	u32 regVal=0;
-	void __iomem *pciewrap_base = pp->pciewrap_base;
 	void __iomem *pciegen3_base1 = pp->pciegen3_base1;
-	void __iomem *pciegen3_base2 = pp->pciegen3_base2;
-	void __iomem *pciegen3_base3 = pp->pciegen3_base3;
 	
-	switch(which)
-	{
-		case 1: synopsys_writel(pciegen3_base1 + PCIE_GPEXD_CORE_CLK_RATIO, 0x10);
-			while (regVal != PCIE1_MISC_STAT__GDA_PAB_DL_UP__MASK)
-			{
-				regVal = synopsys_readl(pciewrap_base + PCIE1_MISC_STAT);
-				regVal &= PCIE1_MISC_STAT__GDA_PAB_DL_UP__MASK;
-			}
-		        break;
-		case 2: synopsys_writel(pciegen3_base2 + PCIE_GPEXD_CORE_CLK_RATIO, 0x10);
-			while (regVal != PCIE2_MISC_STAT__GDA_PAB_DL_UP__MASK)
-			{
-				regVal = synopsys_readl(pciewrap_base + PCIE2_MISC_STAT);
-				regVal &= PCIE2_MISC_STAT__GDA_PAB_DL_UP__MASK;
-			}
-		        break;
-		case 3: synopsys_writel(pciegen3_base3 + PCIE_GPEXD_CORE_CLK_RATIO, 0x10);
-			while (regVal != PCIE3_MISC_STAT__GDA_PAB_DL_UP__MASK)
-			{
-				regVal = synopsys_readl(pciewrap_base + PCIE3_MISC_STAT);
-				regVal &= PCIE3_MISC_STAT__GDA_PAB_DL_UP__MASK;
-			}
-		        break;
-		default:
-			dev_err(pp->dev, "synopsys_pcie_gpexd_core_clk_ratio: which is %d Error\n",which);
-			break;
-	}
-}
+	// PCIE1 has 512 MB AXI target space
+#ifdef	DMA_USE
+#else
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_PIO_CTRL0, ENABLE_ALL_ACCESS_TYPE|ENABLE_PORT);
 #endif
-static void synopsys_pcie_AxiToPexInit(struct pcie_port *pp, int which)
-{
-	void __iomem *pciegen3_base1 = pp->pciegen3_base1;
-	
-	switch (which)	{
-		case 1:
-		// PCIE1 has 512 MB AXI target space
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_PIO_CTRL0,
-			ENABLE_ALL_ACCESS_TYPE|ENABLE_PORT);
 			
-		// - window 0
-		//   - CFG access
-		//   - 64 MB
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_CTRL0,
-		      PAB_AXI_AMAP_CTRL_64_CFG);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE0,  0x00000000);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE0X, 0x00000004);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEL0, 0x00000000);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEH0, 0x00000000);
-
-		// - window 1
-		//   - MEM access
-		//   - 1 MB
-		//   - axi side is not where dependent
-		//   - pex side is where dependent
-	//	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_CTRL1,      0x00030005);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_CTRL1,      0x00100005);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE1,  0x04000000);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE1X, 0x00000004);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEL1, 0x10000000);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEH1, 0x00000000);
-		// - window2
-		//   - MEM access
-		//   - 64 KB
-		//   - axi side is not where dependent
-		//   - pex side is where dependent
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_CTRL2,      0x00010003);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE2,  0x10000000);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE2X, 0x00000004); 
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEL2, 0x10100000);
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEH2, 0x00000000);
-		// - window 3
-		//   - axi side is not where dependent
-		//   - pex side is where dependent
-		//   - MEM access
-		//   - 64 MB
-		break;
-    	default: 
-		dev_err(pp->dev, "synopsys_pcie_AxiToPexInit: which is %d Error\n",which);
-		break;
-	}
+	// - window 0
+	//   - CFG access
+	//   - 64 MB
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_CTRL0,      PAB_AXI_AMAP_CTRL_64_CFG);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE0,  0x00000000);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE0X, 0x00000004);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEL0, 0x00000000);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEH0, 0x00000000);
+
+	// - window 1
+	//   - MEM access
+	//   - 1 MB
+	//   - axi side is not where dependent
+	//   - pex side is where dependent
+#ifdef	MEM_SIZE_1M /* (VxWorks:192k Linux:1MB) */
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_CTRL1,      0x00100005);
+#else
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_CTRL1,      0x00030005);
+#endif
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE1,  0x04000000);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE1X, 0x00000004);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEL1, 0x10000000);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEH1, 0x00000000);
+	// - window2
+	//   - MEM access
+	//   - 64 KB
+	//   - axi side is not where dependent
+	//   - pex side is where dependent
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_CTRL2,      0x00010003);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE2,  0x10000000);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_AXI_BASE2X, 0x00000004); 
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEL2, 0x10100000);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_AMAP_PEX_BASEH2, 0x00000000);
+	// - window 3
+	//   - axi side is not where dependent
+	//   - pex side is where dependent
+	//   - MEM access
+	//   - 64 MB
 }
 
 /*
  * RAM Address setting 0x8_0500_0000 - 0x8_bfff_ffff
  */
-static void synopsys_pcie_PexToAxiInitRc(struct pcie_port *pp, int which)
+static void synopsys_pcie_PexToAxiInitRc(struct pcie_port *pp)
 {
-//	u32 regVal=0;
-//	void __iomem *pciewrap_base  = pp->pciewrap_base;
 	void __iomem *pciegen3_base1 = pp->pciegen3_base1;
-//	void __iomem *pciegen3_base2 = pp->pciegen3_base2;
-//	void __iomem *pciegen3_base3 = pp->pciegen3_base3;
-	unsigned long	kernel_addr = 0x05000000;
-	unsigned long	in_size = 0x0ffffc00;	/* 255MB */
-	unsigned long	pex_addr = 0x05000000;
+	unsigned long	kernel_addr_l = 0x05000000;	// Vx:0x08000000 Li:0x05000000
+	unsigned long	kernel_addr_u = 0x00000008;	
+	unsigned long	pex_addr_u    = 0x05000000;	// Vx:0x08000000 Li:0x05000000
+	unsigned long	pex_addr_l    = 0x00000008;	
+	unsigned long	in_size       = 0x0ffffc00;	/* 255MB */
 	unsigned long	wind_cmd;
 
 	wind_cmd = in_size | 0x05;
 
-	switch (which)
-	{
-	case 1: 
-		synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_PIO_CTRL0, ENABLE_PORT);
+#ifdef	DMA_USE
+#else
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_PIO_CTRL0, ENABLE_PORT);
+#endif
 
-		// window 0
+	// window 0
 	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL0,      wind_cmd);
-//	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE0,  AXI_ADDR_L_DDR);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE0,  kernel_addr);
-//	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE0X, AXI_ADDR_H_DDR);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE0X, 0x00000008);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL0, pex_addr);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH0, 0x00000008);
-
-	kernel_addr = kernel_addr + in_size;
-	pex_addr = pex_addr + in_size;
-		// Windows 1
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE0,  kernel_addr_l);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE0X, kernel_addr_u);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL0, pex_addr_u);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH0, pex_addr_l);
+	kernel_addr_l += in_size;
+	pex_addr_u    += in_size;
+
+	// Windows 1
 	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL1,      wind_cmd);
-//	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1,  AXI_ADDR_L_DDR);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1,  kernel_addr);
-//	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1X, AXI_ADDR_H_DDR);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1X, 0x00000008);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL1, pex_addr);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH1, 0x00000008);
-
-	kernel_addr = kernel_addr + in_size;
-	pex_addr = pex_addr + in_size;
-		// Window 2
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1,  kernel_addr_l);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1X, kernel_addr_u);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL1, pex_addr_u);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH1, pex_addr_l);
+	kernel_addr_l += in_size;
+	pex_addr_u    += in_size;
+
+	// Window 2
 	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL2,      wind_cmd);
-//	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2,  AXI_ADDR_L_DDR);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2,  kernel_addr);
-//	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2X, AXI_ADDR_H_DDR);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2X, 0x00000008);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL2, pex_addr);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH2, 0x00000008);
-
-	kernel_addr = kernel_addr + in_size;
-	pex_addr = pex_addr + in_size;
-
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2,  kernel_addr_l);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2X, kernel_addr_u);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL2, pex_addr_u);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH2, pex_addr_l);
+	kernel_addr_l += in_size;
+	pex_addr_u    += in_size;
+
+	// Window 3
 	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL3,      wind_cmd);
-//	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3,  AXI_ADDR_L_DDR);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3,  kernel_addr);
-//	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3X, AXI_ADDR_H_DDR);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3X, 0x00000008);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL3, pex_addr);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH3, 0x00000008);
-#if 0
-		// window 1
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL1,      PAB_PEX_AMAP_CTRL1);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1,  AXI_ADDR_SP);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1X,  AXI_ADDR_SP);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL1, PEX_ADDR_L_PCIE1_SP);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH1, PEX_ADDR_H_PCIE1_SP);
-
-		// window 2
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL2,      PAB_PEX_AMAP_CTRL2);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2,  AXI_ADDR_XYZ);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL2, PEX_ADDR_PCIE1_XYZ);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH2, 0x00000000);
-		// window 3
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL3,      PAB_PEX_AMAP_CTRL3);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3,  0x00000000); // not applicable
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL3, PEX_ADDR_L_PCIE1_MSI);
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH3, PEX_ADDR_H_PCIE1_MSI);
-#endif 	/* not used */
-		/* INT A Enable */
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_INT_MISC_EN, 0x00000020);
-	break;
-#if 0
-	case 2: 
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_PIO_CTRL0, ENABLE_PORT);
-		// window 0
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_CTRL0,      PAB_PEX_AMAP_CTRL0);
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_AXI_BASE0,  AXI_ADDR_L_DDR);
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_AXI_BASE0X,  AXI_ADDR_H_DDR);
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_PEX_BASEL0, PEX_ADDR_L_PCIE2_DDR_RC); // NOTE special _RC suffix
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_PEX_BASEH0, PEX_ADDR_H_PCIE2_DDR_RC); // NOTE special _RC suffix
-
-		// window 1
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_CTRL1,      PAB_PEX_AMAP_CTRL1);
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_AXI_BASE1,  AXI_ADDR_SP);
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_PEX_BASEL1, PEX_ADDR_L_PCIE2_SP_RC);  // NOTE special _RC suffix
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_PEX_BASEH1, PEX_ADDR_H_PCIE2_SP_RC);  // NOTE special _RC suffix
-		// window 2
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_CTRL2,      PAB_PEX_AMAP_CTRL2);
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_AXI_BASE2,  AXI_ADDR_XYZ);
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_PEX_BASEL2, PEX_ADDR_PCIE2_XYZ_RC);   // NOTE special _RC suffix
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_PEX_BASEH2, 0x00000000);
-		// window 3
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_CTRL3,      PAB_PEX_AMAP_CTRL3);
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_AXI_BASE3,  0x00000000); // not applicable
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_PEX_BASEL3, PEX_ADDR_L_PCIE2_MSI_RC); // NOTE special _RC suffix
-	synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_PEX_BASEH3, PEX_ADDR_H_PCIE2_MSI_RC); // NOTE special _RC suffix
-	break;
-	case 3: 
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_PIO_CTRL0, ENABLE_PORT);
-	// window 0
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_CTRL0,      PAB_PEX_AMAP_CTRL0);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_AXI_BASE0,  AXI_ADDR_L_DDR);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_AXI_BASE0X,  AXI_ADDR_H_DDR);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_PEX_BASEL0, PEX_ADDR_L_PCIE3_DDR);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_PEX_BASEH0, PEX_ADDR_H_PCIE3_DDR);
-
-		// window 1
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_CTRL1,      PAB_PEX_AMAP_CTRL1);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_AXI_BASE1,  AXI_ADDR_SP);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_PEX_BASEL1, PEX_ADDR_L_PCIE3_SP);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_PEX_BASEH1, PEX_ADDR_H_PCIE3_SP);
-		// window 2
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_CTRL2,      PAB_PEX_AMAP_CTRL2);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_AXI_BASE2,  AXI_ADDR_XYZ);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_PEX_BASEL2, PEX_ADDR_PCIE3_XYZ);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_PEX_BASEH2, 0x00000000);
-		// window 3
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_CTRL3,      PAB_PEX_AMAP_CTRL3);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_AXI_BASE3,  0x00000000); // not applicable
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_PEX_BASEL3, PEX_ADDR_L_PCIE3_MSI);
-	synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_PEX_BASEH3, PEX_ADDR_H_PCIE3_MSI);
-
-	break;
-#endif
-	default:
-	dev_err(pp->dev, "synopsys_pcie_PexToAxiInitRc: which is %d Error\n",which);
-	break;
-	}
-}
-#if 0
-static void synopsys_pcie_PexToAxiInitEp(struct pcie_port *pp, int which)
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3,  kernel_addr_l);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3X, kernel_addr_u);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEL3, pex_addr_u);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_PEX_BASEH3, pex_addr_l);
+#ifdef	DEBUG_TRACE
 {
-//	u32 regVal=0;
-//	void __iomem *pciewrap_base  = pp->pciewrap_base;
-	void __iomem *pciegen3_base1 = pp->pciegen3_base1;
-	void __iomem *pciegen3_base2 = pp->pciegen3_base2;
-	void __iomem *pciegen3_base3 = pp->pciegen3_base3;
-
-	switch (which)
-	{
-		case 1: 
-			synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_PIO_CTRL0, ENABLE_PORT);
-			synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_BAR0_F0, AXI_ADDR_DDR | ENABLE_BIT);
-			synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_BAR1_F0, AXI_ADDR_SP  | ENABLE_BIT);
-			synopsys_writel(pciegen3_base1 + PCIE_PAB_PEX_AMAP_BAR2_F0, AXI_ADDR_XYZ | ENABLE_BIT);
-			break;
-		case 2: 
-			synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_PIO_CTRL0, ENABLE_PORT);
-			synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_BAR0_F0, AXI_ADDR_DDR | ENABLE_BIT);
-			synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_BAR1_F0, AXI_ADDR_SP  | ENABLE_BIT);
-			synopsys_writel(pciegen3_base2 + PCIE_PAB_PEX_AMAP_BAR2_F0, AXI_ADDR_XYZ | ENABLE_BIT);
-			break;
-		case 3: 
-			synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_PIO_CTRL0, ENABLE_PORT);
-			synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_BAR0_F0, AXI_ADDR_DDR | ENABLE_BIT);
-			synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_BAR1_F0, AXI_ADDR_SP  | ENABLE_BIT);
-			synopsys_writel(pciegen3_base3 + PCIE_PAB_PEX_AMAP_BAR2_F0, AXI_ADDR_XYZ | ENABLE_BIT);
-			break;
-		default:
-			dev_err(pp->dev, "synopsys_pcie_PexToAxiInitEp: which is %d Error\n",which);
-      		break;
-	}
+	unsigned long	val_u;
+	unsigned long	val_l;
+	unsigned long	set_size;
+	val_u = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE0X);
+	val_l = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE0);
+	set_size = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL0);
+	set_size &= 0xfffffc00;
+	printk( KERN_ERR "%s:PCIe Inbound window 0:0x%x_%08x - 0x%x_%08x\n", __func__, val_u, val_l, val_u, (val_l+set_size));
+	val_u = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1X);
+	val_l = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE1);
+	set_size = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL1);
+	set_size &= 0xfffffc00;
+	printk( KERN_ERR "%s:PCIe Inbound window 1:0x%x_%08x - 0x%x_%08x\n", __func__, val_u, val_l, val_u, (val_l+set_size));
+	val_u = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2X);
+	val_l = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE2);
+	set_size = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL2);
+	set_size &= 0xfffffc00;
+	printk( KERN_ERR "%s:PCIe Inbound window 2:0x%x_%08x - 0x%x_%08x\n", __func__, val_u, val_l, val_u, (val_l+set_size));
+	val_u = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3X);
+	val_l = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_AXI_BASE3);
+	set_size = synopsys_readl(pciegen3_base1 + PCIE_PAB_PEX_AMAP_CTRL3);
+	set_size &= 0xfffffc00;
+	printk( KERN_ERR "%s:PCIe Inbound window 3:0x%x_%08x - 0x%x_%08x\n", __func__, val_u, val_l, val_u, (val_l+set_size));
+}
+#endif	/* DEBUG_TRACE */
 }
-#endif
 
 
 static int synopsys_pcie_establish_link(struct pcie_port *pp)
 {
 	u32 val;
-//	int count = 0;
 	void __iomem *pciewrap_base  = pp->pciewrap_base;
 	void __iomem *pciegen3_base1 = pp->pciegen3_base1;
-//	void __iomem *pciegen3_base2 = pp->pciegen3_base2;
-//	void __iomem *pciegen3_base3 = pp->pciegen3_base3;
 #ifdef	DEBUG_TRACE
 	dev_err(pp->dev, "synopsys_pcie_establish_link: Start(rc_num=%d ep_num=%d nu_num=%d)\n",rc_num,ep_num,nu_num);
 #endif
@@ -925,153 +678,222 @@ static int synopsys_pcie_establish_link(struct pcie_port *pp)
 		dev_err(pp->dev, "synopsys_pcie_establish_link: Link already up\n");
 		return 0;
 	}
-	/* assert PHY Reset */
+	/* Assert PCIe PHY Reset */
 	synopsys_pcie_assert_phy_reset(pp);
 
-	/* assert PIPE Reset */
+	/* Assert PCIe Pipe Resets */
 	synopsys_pcie_assert_pipe_reset(pp);
 	
-	/* assert GPEX Reset */
+	/* Reset PAB, AMBA, PBUS, Link */
 	synopsys_pcie_assert_gpex_reset(pp);
 	
+#if 1   /* ADD */
+	/* Note: PERST_N control is currently broken, so use GPO12 to drive it */
+	synopsys_pcie_ovlctl12(pp);
+#endif
+
+#if 1	/* Change */
+	/* PCIe Endpoint 1 is Root Complex and using lanes 3:0 */
+	synopsys_writel(pciewrap_base + PCIE_SW_BOOTSTRAP, 0x00000011);
+#else
 	/* Set sw_bootstrap Root Complex*/
 	synopsys_pcie_set_bootstrap(pp, PCIE_PORT1, 1);
 	synopsys_pcie_set_bootstrap(pp, PCIE_PORT2, 1);
 	synopsys_pcie_set_bootstrap(pp, PCIE_PORT3, 1);
 	/* Connetc lane */
 	synopsys_pcie_pcie_bifur(pp, PCIE_LANE_PHY_CONF_3);
+#endif
 	
-	// - NEW FOR 55xx PHY
-	//   - Specify ref_clk for PHY
-	//   - use external ref_clk for this test so set phy_ref_use_pad control bit
+	/* Use on-chip reference clock (PHY_REF_ALT_CLK) */
 	val  = synopsys_readl(pciewrap_base + PCIE_PHY_CLK_CTRL);
-	val |= PCIE_PHY_CLK_CTRL__PHY_REF_USE_PAD__MASK;
+	val &= ~PCIE_PHY_CLK_CTRL__PHY_REF_USE_PAD__MASK;
 	synopsys_writel(pciewrap_base + PCIE_PHY_CLK_CTRL, val);
 
-	// - NEW FOR 55xx PHY
-	//   - assert macP_pclkreq_n inputs to PHY for each PIPE being used
-	//   - if you do not do this then PHY will kill mpll_dword_clk output
-	//     and pipe#_phystatus will not fall to indicate pipe is ready
+	/* Enable clock for Endpoint 1, but not the unused endpoints */
 	val = synopsys_readl(pciewrap_base + PCIE_PHY_PIPE_CTRL);
 	val &= PCIE_PHY_PIPE_CTRL__MAC0_PCLKREQ_N__INV_MASK; // MAC0 = PCIE1
-	val &= PCIE_PHY_PIPE_CTRL__MAC1_PCLKREQ_N__INV_MASK; // MAC1 = PCIE2
+	val |= (PCIE_PHY_PIPE_CTRL__MAC1_PCLKREQ | PCIE_PHY_PIPE_CTRL__MAC2_PCLKREQ);
 	synopsys_writel(pciewrap_base + PCIE_PHY_PIPE_CTRL, val);
 	
-	/* de-assert PHY Reset */
+	/* De-assert PCIE PHY Resets */
 	synopsys_pcie_deassert_phy_reset(pp);
 
 	/* de-assert PIPE Reset */
 	synopsys_pcie_deassert_pipe_reset(pp, PCIE_PORT1, 0);
-//	synopsys_pcie_deassert_pipe_reset(pp, PCIE_PORT2, 0);
-//	synopsys_pcie_deassert_pipe_reset(pp, PCIE_PORT3, 0);
 	
-	/*  PIPE Status Check */
+	/* wait until pipe setup is complete */
 	if(synopsys_pcie_pipe_ok(pp, PCIE_PORT1) < 0){
 		printk( KERN_ERR "%s:PCIe Status error\n", __func__);
 		return	-1;
 	}
-//	synopsys_pcie_pipe_ok(pp, PCIE_PORT2);
-//	synopsys_pcie_pipe_ok(pp, PCIE_PORT3);
 	
-	/* de-assert GPEX Reset */
+	/* Deassert GPEX Resets for RC endpoint 1 */
 	synopsys_pcie_deassert_gpex_reset(pp, PCIE_PORT1, 0);
-//	synopsys_pcie_deassert_gpex_reset(pp, PCIE_PORT2, 0);
-//	synopsys_pcie_deassert_gpex_reset(pp, PCIE_PORT3, 0);
-	
-	/* Set GPEXD_CORE_CLK_RATIO  */
-//	synopsys_pcie_gpexd_core_clk_ratio(pp, rc_num);	/* yamano */
-//	synopsys_pcie_gpexd_core_clk_ratio(pp, ep_num);
-	//-------------------------------------------------------
-	// - INITIALIZE AXI and PEX WINDOWS
-	//-------------------------------------------------------
-	synopsys_writel(pciegen3_base1 + PCIE_PAB_CTRL, 0x00000a2f);	/* yamano */
-//	synopsys_writel(pciegen3_base2 + PCIE_PAB_CTRL, 0x00000a2f);
-	/* initialize AXI to PEX windows for RC to EP accesses */
-	synopsys_pcie_AxiToPexInit(pp, rc_num);
 	
-	/* initialize AXI to PEX windows for EP to RC accesses */
-//	synopsys_pcie_AxiToPexInit(pp, ep_num, rc_num, rc_num);	/* yamano */
-	
-	/* initialize root complex registers */
-	synopsys_pcie_PexToAxiInitRc(pp, PCIE_PORT1);
-	
-	/* initialize endpoint registers */
-//	synopsys_pcie_PexToAxiInitEp(pp, ep_num);	/* yamano debug */
+#if 1	/* ADD */
+	{
+        void __iomem *addr;
+        addr = ioremap_nocache(0x040800c0,4);
+        writel((1<<12), addr);
+        iounmap(addr);
+	}
+	/* Generate 300MHz PCI clock from core clock */
+#define PCIE_FREQ		(266*1000*1000)
+#define PCIE_CLK_266MHZ		(PCIE_FREQ/(266*1000*1000/16))
+#define PCIE_CORE_RESET_WAIT	200			/* 200 ms */
+        synopsys_writel(pciegen3_base1+PCIE_GPEXD_CORE_CLK_RATIO, PCIE_CLK_266MHZ );
 	
-//	/* check if the link is up or not */
-//	while (!synopsys_pcie_link_up(pp)) {
-//		mdelay(100);
-//		count++;
-//		if (count == 10) {
-//			dev_err(pp->dev, "PCIe Link Fail\n");
-//			return -EINVAL;
-//		}
-//	}
-//	
-//	dev_info(pp->dev, "Link up\n");
-//out:
+	//msleep( PCIE_CORE_RESET_WAIT );
+	msleep( PCIE_CORE_RESET_WAIT * 10 );
+#endif
+
 #ifdef	DEBUG_TRACE
 	dev_err(pp->dev, "synopsys_pcie_establish_link: End\n");
 #endif
 	return 0;
 }
 
-static void exynos_pcie_clear_irq_pulse(struct pcie_port *pp)
+static void exynos_pcie_clear_irq_pulse(int irq_no)		// Check OK
 {
-	void __iomem *resetgen_base  = pp->resetgen_base;
-	
-	synopsys_writel(resetgen_base + PCIE1_INT_CLR, PCIE1_INT_CLR__PERST_N_PIN__MASK | PCIE1_INT_CLR__GDA_PAB__MASK);
-//	synopsys_writel(resetgen_base + PCIE1_INT_CLR, PCIE2_INT_CLR__PERST_N_PIN__MASK | PCIE2_INT_CLR__GDA_PAB__MASK);
-//	synopsys_writel(resetgen_base + PCIE1_INT_CLR, PCIE3_INT_CLR__PERST_N_PIN__MASK | PCIE3_INT_CLR__GDA_PAB__MASK);
-	return;
+//	u32     val;
+#ifdef	DEBUG_TRACE_IRQ
+	printk(KERN_ERR "PCIe:%s: Start\n",__func__);
+#endif
+//	val = synopsys_readl(pcie_1_reg + PCIE_PAB_AXI_INT_MISC_STAT);	
+//#if 1
+//	if ( val != 0x20 ) { 		// INTA
+//		printk(KERN_ERR, "PCIe IRQ Status=0x%08x(see 0xc00)\n", val);
+//	}
+//#endif
+//	if ( irq_no == 0 ){
+//		/* clear interrupt at PAB (this register is w1c) */
+//		if ( val ) {
+//			synopsys_writel(pcie_1_reg + PCIE_PAB_AXI_INT_MISC_STAT, val);
+//		}
+//	}
+//	if ( irq_no == 96 ) {
+//		synopsys_writel(pcie_1_reg + PCIE_PAB_AXI_INT_MISC_STAT, 0x20);	//INTA
+//	}
+//
+	/* clear interrupt at PCIe General (this register is w1c) */
+	synopsys_writel(pcie_wrap + PCIE1_INT_CLR, PCIE1_INT_CLR__PERST_N_PIN | PCIE1_INT_CLR__GDA_PAB);
+#ifdef	DEBUG_TRACE_IRQ
+	printk(KERN_ERR "PCIe:%s: End\n", __func__);
+#endif
 }
-#if 0
-static void synopsys_pcie_enable_irq_pulse(struct pcie_port *pp)
-{
-//	u32 val;
-	void __iomem *resetgen_base  = pp->resetgen_base;
 
-	/* enable INTX interrupt */
-	synopsys_writel(resetgen_base + PCIE1_INT_EN, PCIE1_INT_EN__PERST_N_PIN__MASK | PCIE1_INT_EN__GDA_PAB__MASK);
-//	synopsys_writel(resetgen_base + PCIE2_INT_EN, PCIE2_INT_EN__PERST_N_PIN__MASK | PCIE2_INT_EN__GDA_PAB__MASK);
-//	synopsys_writel(resetgen_base + PCIE3_INT_EN, PCIE3_INT_EN__PERST_N_PIN__MASK | PCIE3_INT_EN__GDA_PAB__MASK);
-	return;
-}
-#endif
-static irqreturn_t exynos_pcie_irq_handler(int irq, void *arg)
+#ifdef	PCIE_IRQ_USE
+static irqreturn_t pcie_irq_handler(int irq, void *arg)		// Check OK
 {
-	struct pcie_port *pp = arg;
-
-	exynos_pcie_clear_irq_pulse(pp);
+	printk(KERN_ERR "PCIe:%s: Call\n", __func__);
+	synopsys_writel(pcie_wrap + PCIE_INT_CLR, PCIE_INT_CLR__PCIETP_WRAP);
 	return IRQ_HANDLED;
 }
-#if 0
-static void synopsys_pcie_enable_interrupts(struct pcie_port *pp)
+#endif	/* PCIE_IRQ_USE */
+
+static irqreturn_t exynos_pcie_irq_handler(int irq, void *arg)		// Check OK
 {
-	synopsys_pcie_enable_irq_pulse(pp);
-	return;
-}
+//	struct pcie_port *pp = arg;
+
+#ifdef	DEBUG_TRACE_IRQ
+	printk(KERN_ERR "PCIe:%s: Start\n", __func__);
 #endif
-/* PCIe Card Driver Interrupt helper function */
-int	synopsys_pcie_interrupt_clear(unsigned int irq_no)
-{
-	synopsys_writel(pcie_1_reg + PCIE_PAB_AXI_INT_MISC_STAT, irq_no);
-	synopsys_writel(pcie_wrap + PCIE_PCIE1_INT_CLR, PCIE_INT_GDA_PAB);
-	return	0;
+#ifdef	DEBUG_TRACE
+	{
+		u32     val;
+		// 0x848
+		val = synopsys_readl(pcie_1_reg + PCIE1_PAB_AXI_PIO_STAT0);	
+		if ( val )
+			printk(KERN_ERR "AXI PIO               Status Register=0x%x\n", val);
+
+		val = synopsys_readl(pcie_1_reg + 0x84c);	
+		if ( val )
+			printk(KERN_ERR "AMBA PIO Slave        Status Register=0x%x\n", val);
+
+		// 0x8e8
+		val = synopsys_readl(pcie_1_reg + 0x8e8);	
+		if ( val )
+			printk(KERN_ERR "PEX PIO               Status Register=0x%x\n", val);
+		synopsys_writel(pcie_1_reg + 0x8e8, val);
+
+		val = synopsys_readl(pcie_1_reg + 0x8ec);	
+		if ( val )
+			printk(KERN_ERR "PEX PIO Master        Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0x984);	
+		if ( val )
+			printk(KERN_ERR "CSR PIO Slave         Status Register=0x%x\n", val);
+
+		// 0xba8
+		val = synopsys_readl(pcie_1_reg + PCIE1_PAB_PEX_INT_STAT);	
+		if ( (val & 0xfffffffa) != 0 )
+			printk(KERN_ERR "PEX Interrupt         Status Register=0x%x\n", val);
+		synopsys_writel(pcie_1_reg + PCIE1_PAB_PEX_INT_STAT, val);
+		
+		// 0xbf4
+		val = synopsys_readl(pcie_1_reg + 0xbf4);	
+		if ( (val & 0xfffefffe) != 0 )
+			printk(KERN_ERR "AMBA Interrupt PIO    Status Register=0x%x\n", val);
+		synopsys_writel(pcie_1_reg + 0xbf4, val);
+
+
+		val = synopsys_readl(pcie_1_reg + 0xbf8);	
+		if ( val )
+			printk(KERN_ERR "AMBA Interrupt WDMA   Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0xbfc);	
+		if ( val )
+			printk(KERN_ERR "AMBA Interrupt RDMA   Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0xc00);	
+		if ( (val != 0x00) && (val != 0x20) )
+			printk(KERN_ERR "AMBA Interrupt Misc   Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0xc64);	
+		if ( val )
+			printk(KERN_ERR "PEX Inbound MSI       Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0x990);	
+		if ( val )
+			printk(KERN_ERR "DMA Descriptor Master Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0x9a8);	
+		if ( val )
+			printk(KERN_ERR "WDMA Engine           Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0x9ac);	
+		if ( val )
+			printk(KERN_ERR "WDMA Engine Master    Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0xa48);	
+		if ( val )
+			printk(KERN_ERR "RDMA Engine           Status Register=0x%x\n", val);
+		val = synopsys_readl(pcie_1_reg + 0xa4c);	
+		if ( val )
+			printk(KERN_ERR "RDMA Engine Master    Status Register=0x%x\n", val);
+	}
+#endif	/* DEBUG_TRACE */
+	exynos_pcie_clear_irq_pulse(0);
+#ifdef	DEBUG_TRACE_IRQ
+	printk(KERN_ERR, "PCIe:%s: End\n");
+#endif
+	return IRQ_HANDLED;
 }
-EXPORT_SYMBOL(synopsys_pcie_interrupt_clear);
+
+/* PCIe Card Driver Interrupt helper function */
+//int	synopsys_pcie_interrupt_clear(unsigned int irq_no)
+//{
+//#ifdef	DEBUG_TRACE_IRQ
+//	printk(KERN_ERR, "PCIe:%s: Start(irq_no=0x%x)\n", irq_no);
+//#endif
+//	synopsys_writel(pcie_1_reg + PCIE_PAB_AXI_INT_MISC_STAT, irq_no);
+//	synopsys_writel(pcie_wrap + PCIE_PCIE1_INT_CLR, PCIE_INT_GDA_PAB);
+//	exynos_pcie_clear_irq_pulse(irq_no);
+//#ifdef	DEBUG_TRACE_IRQ
+//	printk(KERN_ERR, "PCIe:%s: End\n", irq_no);
+//#endif
+//	return	0;
+//}
+//EXPORT_SYMBOL(synopsys_pcie_interrupt_clear);
 
 static int  synopsys_pcie_host_init(struct pcie_port *pp)
 {
-//	struct pcie_port_info *config = &pp->config;
-	u32 val,result,wait_loop;
-//	u64	adr_base;
+	u32 val;
 	void __iomem *resetgen_base  = pp->resetgen_base;
 	void __iomem *pciewrap_base  = pp->pciewrap_base;
 	void __iomem *pciegen3_base1 = pp->pciegen3_base1;
-//	void __iomem *pciegen3_base2 = pp->pciegen3_base2;
-//	void __iomem *pciegen3_base3 = pp->pciegen3_base3;
-	//void __iomem *conFig;
 
 #ifdef	DEBUG_TRACE
 	dev_err(pp->dev, "synopsys_pcie_host_init: Start\n");
@@ -1089,6 +911,33 @@ static int  synopsys_pcie_host_init(struct pcie_port *pp)
 		return	-1;
 	}
 
+#if 1	/* ADD */ 
+	/* wait until link established */
+	{
+		int	i;
+		u32 	val;
+		for( i = 0; i < 10; i++ ){
+			val = synopsys_readl(pciewrap_base + PCIE1_MISC_STAT);
+			smp_wmb();
+			if( (val & PCIE1_MISC_STAT__GDA_PAB_DL_UP__MASK) != 0 ){
+				printk( KERN_ERR "PCIe Link 1 Establish\n");
+				break;
+			}
+			msleep(10);
+		}
+		if ( i >= 10 ) {
+			dev_err(pp->dev, "PCIe can't Data link Up\n");
+			return  -1;
+		}
+	}
+#endif
+
+	/*-- setup PAB --*/
+//	synopsys_writel(pciegen3_base1 + PCIE_PAB_CTRL, 0x0000022f);
+	synopsys_writel(pciegen3_base1 + PCIE_PAB_CTRL, 0x0000023f);	// Maximum Burst Length is 16
+	synopsys_pcie_AxiToPexInit(pp);
+	synopsys_pcie_PexToAxiInitRc(pp);
+
 	/* PCIE1 (RC) */
 	val = synopsys_readl(pciegen3_base1 + PCIE_GPEXP_CFG_VENDORID);
 	if ( val != 0x000811de ) {
@@ -1107,45 +956,24 @@ static int  synopsys_pcie_host_init(struct pcie_port *pp)
 	if ( val != 0x55001135 ) {
 		dev_err(pp->dev, "synopsys_pcie_host_init: PCIE_GPEXD_ID error rc(0x%x != 0x123411de)\n",val);
 	}
-	synopsys_writel(pciegen3_base1 + PCIE_GPEXD_CLASSCODE, 0xffffffff);
-	val = synopsys_readl(pciegen3_base1 + PCIE_GPEXD_CLASSCODE);
-//	dev_err(pp->dev, "PCIE_GPEXD_CLASSCODE 0x%x\n",val);
-
-        synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_BASE2_PRIBUS, 0x00010100);
-        val = synopsys_readl(pciegen3_base1 + PCIE_GPEXP_CFG_BASE2_PRIBUS);
-//      dev_err(pp->dev, "PCIE_GPEXP_CFG_BASE2_PRIBUS 0x%x\n",val);
-
-	/* SET GPEXD_CFG_RDY bit */
-	val = synopsys_readl(pciegen3_base1 + PCIE_GPEXD_CFG_RDY);
-	if ( (val & 0x1) != 0x0 ) {
-		dev_err(pp->dev, "synopsys_pcie_host_init: PCIE_GPEXD_CFG_RDY error\n");
-	}
-/*
-	val = synopsys_readl(pciegen3_base2 + PCIE_GPEXD_CFG_RDY);
-	if ( (val & 0x1) != 0x0 ) {
-		dev_err(pp->dev, "synopsys_pcie_host_init: PCIE_GPEXD_CFG_RDY error\n");
-	}
-*/	
+	/* set config ready */
 	val = synopsys_readl(pciegen3_base1 + PCIE_GPEXD_CFG_RDY);
 	val |= 0x1;
 	synopsys_writel(pciegen3_base1 + PCIE_GPEXD_CFG_RDY, val);
-/*	
-	val = synopsys_readl(pciegen3_base2 + PCIE_GPEXD_CFG_RDY);
-	val |= 0x1;
-	synopsys_writel(pciegen3_base2 + PCIE_GPEXD_CFG_RDY, val);
-*/	
-	/* locally initialize more PCIE1 RC CFG regs (45xx legacy code) */
-	val = synopsys_readl(pciegen3_base1 + PCIE_GPEXP_CFG_CACHE);
 
-	val = synopsys_readl(pciegen3_base1 + PCIE_GPEXP_CFG_BASE3_IOBASE);
-	synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_BASE4_MEMBASE, PCIE1_MEM_LIMIT_BASE);
-
-	val = synopsys_readl(pciegen3_base1 + PCIE_GPEXP_CFG_BASE4_MEMBASE);
+	/* locally initialize more PCIE1 RC CFG regs (45xx legacy code) */
+	synopsys_writel(pciegen3_base1 + 0x10, 0x04000000);		//
+	synopsys_writel(pciegen3_base1 + 0x14, 0x00000004);		//
 	synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_BASE5_PMEMBASE, PCIE1_PMEM_LIMIT_BASE_L);
-
-	val = synopsys_readl(pciegen3_base1 + PCIE_GPEXP_CFG_BASE5_PMEMBASE);
-	synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_X_PBASEUDW, PCIE1_PMEM_BASE_U);
-	synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_SUBVENID_PLIMITUDW, PCIE1_PMEM_LIMIT_U);
+	synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_BASE5_PMEMBASE, 0x04100400);	// 0x0024 -> 0xFFFF0000
+	synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_X_PBASEUDW, 0x4);		// 0x0028 -> 0x00002000 =>0x4
+	synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_SUBVENID_PLIMITUDW, 0x4);	// 0x002C -> 0x000032FF =>0x4
+	/* set bus number: Primory = 0x00, Secondary = 0x01, Subordinate = 0x01 */
+	synopsys_writel(pciegen3_base1 + PCIE_GPEXP_CFG_BASE2_PRIBUS, 0x10100);		// 0x0018 -> 0x1i0100
+	/* set snoop enable */
+	val = synopsys_readl(pciegen3_base1 + 0x0054);
+	val &= ~0x00000800;
+	synopsys_writel(pciegen3_base1 + 0x0054, val);
 	
 	/* SET BITS in PCIE1 PCIE Command Register */
 	val  = synopsys_readl(pciegen3_base1 + PCIE_GPEXP_CFG_COMMAND);
@@ -1157,41 +985,40 @@ static int  synopsys_pcie_host_init(struct pcie_port *pp)
 //	val &= PCIE1_MISC_CTRL__PIOS_CONV_SEL__INV_MASK;
 //	val |= (0x1 << PCIE1_MISC_CTRL__PIOS_CONV_SEL__SHIFT);
 //	synopsys_writel(resetgen_base + PCIE1_MISC_CTRL, val);
-	result = 0;
-	wait_loop=0;
-	val = synopsys_readl(pciewrap_base + PCIE1_MISC_STAT);
-	while(val != PCIE1_MISC_STAT__GDA_PAB_DL_UP__MASK){
-		if(wait_loop > 50){
-			result = 1;
-			break;
-		}
-		msleep(10);
-		wait_loop++;
-		val = synopsys_readl(pciewrap_base + PCIE1_MISC_STAT);
-		smp_wmb();
-	};
-	if(result != 0){
-		dev_err(pp->dev, "PCIe can't Data link Up\n");
-		return	-1;
-	}
+//
 	/* Interrupt clear reg base */
-	pcie_wrap = pp->pciewrap_base;
+	pcie_wrap  = pp->pciewrap_base;
 	pcie_1_reg = pp->pciegen3_base1;
 
 	/* host bridge interrupt routing enable */
-	val = synopsys_readl(pciewrap_base +PCIE_PCIE1_INT_EN);
-	val |= PCIE_INT_GDA_PAB;
-	synopsys_writel(pciewrap_base + PCIE_PCIE1_INT_EN, val);
+	val = synopsys_readl(pciewrap_base +PCIE1_INT_EN);
+	val |= PCIE1_INT_EN__GDA_PAB;
+	synopsys_writel(pciewrap_base + PCIE1_INT_EN, val);
+#ifdef	PCIE_IRQ_USE
+	val = synopsys_readl(pciewrap_base + PCIE_INT_EN);
+	val |= PCIE_INT_EN__PCIETP_WRAP_rerror;
+	synopsys_writel(pciewrap_base + PCIE1_INT_EN, val);
+//	val = synopsys_readl(pciewrap_base + 0xbe0);
+//	val |= 0x01100100;
+//	synopsys_writel(pciewrap_base + 0xbe0, val);
+#endif
 
 	val = synopsys_readl(pciegen3_base1 + PCIE_PAB_AXI_INT_MISC_EN);
+#ifdef	PCIE_IRQ_USE
+	val |= PCIE_AXI_INT_INTA | 0x200003f0;
+#else
 	val |= PCIE_AXI_INT_INTA;
+#endif
 	synopsys_writel(pciegen3_base1 + PCIE_PAB_AXI_INT_MISC_EN, val);
 
-//	synopsys_writel(pciewrap_base + PCIE_INT_EN, 0x00000001);
-//	synopsys_pcie_enable_interrupts(pp);
-//out:
+#ifdef  PCIE_IRQ_USE
+	val = synopsys_readl(pciegen3_base1 + PCIE1_PAB_PEX_INT_EN);
+	val |= 0x3fa;
+	synopsys_writel(pciegen3_base1 + PCIE1_PAB_PEX_INT_EN, val);
+#endif	/* PCIE_IRQ_USE */
+
 #ifdef	DEBUG_TRACE
-	dev_err(pp->dev, "synopsys_pcie_host_init:%x End\n",pciegen3_base1);
+	dev_err(pp->dev, "synopsys_pcie_host_init: End(pciegen3_base1=0x%x)\n",pciegen3_base1);
 #endif
 	return	0;
 }
@@ -1211,6 +1038,9 @@ static int synopsys_add_pcie_port(struct pcie_port *pp, struct platform_device *
 	pp->resetgen_base = devm_ioremap_resource(&pdev->dev, tmp);
 	if (IS_ERR(pp->resetgen_base))
 		return PTR_ERR(pp->resetgen_base);
+#ifdef	DEBUG_TRACE
+	dev_err(pp->dev, "reset gen: 0x04010000->(v)0x%x\n",pp->resetgen_base);
+#endif
 	
 	
 	tmp = platform_get_resource(pdev, IORESOURCE_MEM, 1);
@@ -1221,6 +1051,9 @@ static int synopsys_add_pcie_port(struct pcie_port *pp, struct platform_device *
 	pp->pciewrap_base = devm_ioremap_resource(&pdev->dev, tmp);
 	if (IS_ERR(pp->pciewrap_base))
 		return PTR_ERR(pp->pciewrap_base);
+#ifdef	DEBUG_TRACE
+	dev_err(pp->dev, "warp     : 0x04a70000->(v)0x%x\n",pp->pciewrap_base);
+#endif
 	
 	
 	tmp = platform_get_resource(pdev, IORESOURCE_MEM, 2);
@@ -1231,28 +1064,10 @@ static int synopsys_add_pcie_port(struct pcie_port *pp, struct platform_device *
 	pp->pciegen3_base1 = devm_ioremap_resource(&pdev->dev, tmp);
 	if (IS_ERR(pp->pciegen3_base1))
 		return PTR_ERR(pp->pciegen3_base1);
+#ifdef	DEBUG_TRACE
+	dev_err(pp->dev, "port1    : 0x04a40000->(v)0x%x\n",pp->pciegen3_base1);
+#endif
 	
-#if 0	
-	tmp = platform_get_resource(pdev, IORESOURCE_MEM, 3);
-	if (!tmp) {
-		dev_err(pp->dev, "add_pcie_port: couldn't get pciegen3_2 base resource\n");
-		return -EINVAL;
-	}
-	pp->pciegen3_base2 = devm_ioremap_resource(&pdev->dev, tmp);
-	if (IS_ERR(pp->pciegen3_base2))
-		return PTR_ERR(pp->pciegen3_base2);
-	
-	
-	tmp = platform_get_resource(pdev, IORESOURCE_MEM, 4);
-	if (!tmp) {
-		dev_err(pp->dev, "add_pcie_port: couldn't get pciegen3_3 base resource\n");
-		return -EINVAL;
-	}
-	pp->pciegen3_base3 = devm_ioremap_resource(&pdev->dev, tmp);
-	if (IS_ERR(pp->pciegen3_base3))
-		return PTR_ERR(pp->pciegen3_base3);
-#endif	/* saving vartual address space */	
-//	pp->irq = IRQ_V2M_PCIE;
 	pp->irq = platform_get_irq(pdev, 0);
 	if (!pp->irq) {
 		dev_err(pp->dev, "add_pcie_port: failed to get irq\n");
@@ -1260,10 +1075,17 @@ static int synopsys_add_pcie_port(struct pcie_port *pp, struct platform_device *
 	}
 	ret = devm_request_irq(&pdev->dev, pp->irq, exynos_pcie_irq_handler, IRQF_SHARED, "synopsys-pcie", pp);
 	if (ret) {
-		dev_err(pp->dev, "add_pcie_port: failed to request irq\n");
+		dev_err(pp->dev, "add_pcie_port: failed to request irq(PCIE)\n");
 		return ret;
 	}
-	
+#ifdef	PCIE_IRQ_USE
+	pp->irq_pciebus = 95;
+	ret = devm_request_irq(&pdev->dev, pp->irq_pciebus, pcie_irq_handler, IRQF_SHARED, "pcie_bus", pp);
+	if (ret) {
+		dev_err(pp->dev, "add_pcie_port: failed to request irq(PCIE_PORT1)\n");
+		return ret;
+	}
+#endif
 	
 	pp->root_bus_nr = 0;
 
@@ -1284,18 +1106,10 @@ static int synopsys_add_pcie_port(struct pcie_port *pp, struct platform_device *
 static int __init synopsys_pcie_probe(struct platform_device *pdev)
 {
 	struct pcie_port *pp;
-#if 1
 #ifdef	DEBUG_TRACE
 	dev_info(&pdev->dev, "synopsys_pcie_probe :Start\n");
 #endif
-#else
-	struct device_node *np = pdev->dev.of_node;
-	struct of_pci_range range;
-	struct of_pci_range_parser parser;
-#endif
 	int ret;
-//	struct device_node *np;
-
 
 	pp = devm_kzalloc(&pdev->dev, sizeof(*pp), GFP_KERNEL);
 	if (!pp) {
@@ -1303,90 +1117,84 @@ static int __init synopsys_pcie_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	pp->dev = &pdev->dev;
-#if 0
-	if (of_pci_range_parser_init(&parser, np)) {
-		dev_err(pp->dev, "synopsys_pcie_probe: missing ranges property\n");
-		return -EINVAL;
-	}
-
-	/* Get the I/O and memory ranges from DT */
-	for_each_of_pci_range(&parser, &range) {
-		unsigned long restype = range.flags & IORESOURCE_TYPE_BITS;
-		if (restype == IORESOURCE_IO) {
-			of_pci_range_to_resource(&range, np, &pp->io);
-			pp->io.name = "I/O";
-			pp->io.start = max_t(resource_size_t,
-					     PCIBIOS_MIN_IO,
-					     range.pci_addr + global_io_offset);
-			pp->io.end = min_t(resource_size_t,
-					   IO_SPACE_LIMIT,
-					   range.pci_addr + range.size
-					   + global_io_offset);
-			pp->config.io_size = resource_size(&pp->io);
-			pp->config.io_bus_addr = range.pci_addr;
-		}
-		if (restype == IORESOURCE_MEM) {
-			of_pci_range_to_resource(&range, np, &pp->mem);
-			pp->mem.name = "MEM";
-			pp->config.mem_size = resource_size(&pp->mem);
-			pp->config.mem_bus_addr = range.pci_addr;
-		}
-		if (restype == 0) {
-			of_pci_range_to_resource(&range, np, &pp->cfg);
-			pp->config.cfg0_size = resource_size(&pp->cfg)/2;
-			pp->config.cfg1_size = resource_size(&pp->cfg)/2;
-		}
+#if 0	/* TEST */
+	{
+		void __iomem *base;
+		u32	tmp;
+		base = ioremap_nocache(0x04060000, 0xe000);
+		printk(KERN_ERR "CCI_COR      : 0x%08x\n", readl(base + 0x0000));
+		printk(KERN_ERR "CCI_SCR      : 0x%08x\n", readl(base + 0x0004));
+		printk(KERN_ERR "CCI_SECACC   : 0x%08x\n", readl(base + 0x0008));
+		printk(KERN_ERR "CCI_STATUS   : 0x%08x\n", readl(base + 0x000c));
+		printk(KERN_ERR "CCI_PMR      : 0x%08x\n", readl(base + 0x0100));
+
+		printk(KERN_ERR "CCI_SNOOP_S0 : 0x%08x\n", readl(base + 0x1000));
+		printk(KERN_ERR "CCI_SHROV_S0 : 0x%08x\n", readl(base + 0x1004));
+		printk(KERN_ERR "CCI_RQOSOV_S0: 0x%08x\n", readl(base + 0x1100));
+		printk(KERN_ERR "CCI_WQOSOV_S0: 0x%08x\n", readl(base + 0x1104));
+		printk(KERN_ERR "CCI_QOSCTL_S0: 0x%08x\n", readl(base + 0x110c));
+		printk(KERN_ERR "CCI_MAXOT_S0 : 0x%08x\n", readl(base + 0x1110));	// 0e->10
+		printk(KERN_ERR "CCI_REGTGT_S0: 0x%08x\n", readl(base + 0x1130));
+		printk(KERN_ERR "CCI_QOSSCL_S0: 0x%08x\n", readl(base + 0x1134));
+		printk(KERN_ERR "CCI_QOSRNG_S0: 0x%08x\n", readl(base + 0x1138));
+
+		printk(KERN_ERR "PeripheralID4: 0x%08x\n", readl(base + 0x0fd0));
+		printk(KERN_ERR "PeripheralID5: 0x%08x\n", readl(base + 0x0fd4));
+		printk(KERN_ERR "PeripheralID6: 0x%08x\n", readl(base + 0x0fd8));
+		printk(KERN_ERR "PeripheralID7: 0x%08x\n", readl(base + 0x0fdc));
+		printk(KERN_ERR "PeripheralID0: 0x%08x\n", readl(base + 0x0fe0));
+		printk(KERN_ERR "PeripheralID1: 0x%08x\n", readl(base + 0x0fe4));
+		printk(KERN_ERR "PeripheralID2: 0x%08x\n", readl(base + 0x0fe8));
+		printk(KERN_ERR "PeripheralID3: 0x%08x\n", readl(base + 0x0fec));
+		printk(KERN_ERR "Component ID0: 0x%08x\n", readl(base + 0x0ff0));
+		printk(KERN_ERR "Component ID1: 0x%08x\n", readl(base + 0x0ff4));
+		printk(KERN_ERR "Component ID2: 0x%08x\n", readl(base + 0x0ff8));
+		printk(KERN_ERR "Component ID3: 0x%08x\n", readl(base + 0x0ffc));
+//		writel( 0x1, base + 0x0008);
+//		printk(KERN_ERR "CCI_SECACC   : 0x%08x\n", readl(base + 0x0008));
+		writel( 0x3, base + 0x1000);
+		while (readl(base + 0x100c) & 0x1);
+
+		printk(KERN_ERR "CCI_SNOOP_S0 : 0x%08x\n", readl(base + 0x1000));
+		iounmap(base);
 	}
 #endif
+	pp->dev = &pdev->dev;
+
 	/* Configureation resource */
 	pp->io.name	= "Multiport";
 	pp->io.start	= 0x410000000ULL;
 	pp->io.end	= 0x41000ffffULL;
 	pp->io.flags	= IORESOURCE_IO;
-//	pp->va_io = ioremap(0x410000000ULL,SZ_64K);
+
 	pp->config[0].io.name = "Port 0 IO space";
 	pp->config[0].io.start = 0x410000000ULL;
 	pp->config[0].io.end   = 0x41000FFFFULL;
 	pp->config[0].io.flags = IORESOURCE_IO;
 	pp->config[0].io_size = resource_size(&pp->config[0].io);
-//	printk(KERN_ERR "I/O size %x \n",pp->config[0].io_size);
-//	pp->config[0].io_bus_addr	= 0x410000000ULL;
+
 	pp->mem.name	= "Memory";
 	pp->mem.start	= 0x404000000ULL;
+#ifdef	MEM_SIZE_1M
 	pp->mem.end	= 0x4040fffffULL;
+#else
+	pp->mem.end	= 0x40402ffffULL;
+#endif
 	pp->mem.flags	= IORESOURCE_MEM;
 	pp->va_cfg = ioremap(0x400000000ULL,SZ_32M);
-//	pp->va_mem = ioremap(0x404000000ULL,SZ_128M+SZ_64K);
+
 	pp->config[0].mem.name = "Port 0 Memory";
 	pp->config[0].mem.start = 0x404000000ULL;
+#ifdef	MEM_SIZE_1M
 	pp->config[0].mem.end  	= 0x4040fffffULL;
+#else
+	pp->config[0].mem.end  	= 0x40402ffffULL;
+#endif
 	pp->config[0].mem.flags = IORESOURCE_MEM;
 	pp->config[0].mem_size = resource_size(&pp->config[0].mem);
-//	printk(KERN_ERR "Memory size %x \n",pp->config[0].mem_size);
-//	pp->config[0].mem_bus_addr	= 0x400000000ULL;
 
 	pp->config[0].irq = LM2_IRQ_PCIE1;	/* device interrupt by port */
-/*
-	pp->clk = devm_clk_get(&pdev->dev, "pcie");
-	if (IS_ERR(pp->clk)) {
-		dev_err(pp->dev, "synopsys_pcie_probe: Failed to get pcie rc clock\n");
-		return PTR_ERR(pp->clk);
-	}
-	ret = clk_prepare_enable(pp->clk);
-	if (ret)
-		return ret;
 
-	pp->bus_clk = devm_clk_get(&pdev->dev, "pcie_bus");
-	if (IS_ERR(pp->bus_clk)) {
-		dev_err(pp->dev, "synopsys_pcie_probe: Failed to get pcie bus clock\n");
-		ret = PTR_ERR(pp->bus_clk);
-		goto fail_clk;
-	}
-	ret = clk_prepare_enable(pp->bus_clk);
-	if (ret)
-		goto fail_clk;
-*/
 	ret = synopsys_add_pcie_port(pp, pdev);
 	if (ret < 0)
 		goto fail_bus_clk;
@@ -1402,6 +1210,7 @@ static int __init synopsys_pcie_probe(struct platform_device *pdev)
 #endif
 
 	platform_set_drvdata(pdev, pp);
+	pcie_probe_end=1;
 #ifdef	DEBUG_TRACE
 	dev_err(pp->dev, "synopsys_pcie_probe: End\n");
 #endif
@@ -1419,6 +1228,7 @@ static int __exit synopsys_pcie_remove(struct platform_device *pdev)
 	struct pcie_port *pp = platform_get_drvdata(pdev);
 	clk_disable_unprepare(pp->bus_clk);
 	clk_disable_unprepare(pp->clk);
+	pcie_probe_end=0;
 	return 0;
 }
 
@@ -1470,6 +1280,7 @@ void lm2_pcie_suspend(void)
 	int i=0;
 	void __iomem *base;
 	/* reset gen (  1)*/
+	if ( pcie_probe_end == 1 ) {
 	base = ioremap_nocache(0x04010000, 0x120);
 	pcie_reg_save(base, &i, 0x104,  1);
 	iounmap(base);
@@ -1539,6 +1350,7 @@ void lm2_pcie_suspend(void)
 	reg_bak_chksum=0;
 	for(i=0; i<LM2_REGBAK_SIZE; i++)
 		reg_bak_chksum += reg_bak[i];
+	}
 
 }
 EXPORT_SYMBOL(lm2_pcie_suspend);
@@ -1548,6 +1360,8 @@ void lm2_pcie_resume(struct device *dev)
 	int i=0;
 	void __iomem *base;
 	unsigned int    tmp;
+
+	if ( pcie_probe_end == 1) {
 	/* chksum chk */
 	tmp=0;
 	for(i=0; i<LM2_REGBAK_SIZE; i++)
@@ -1623,6 +1437,7 @@ void lm2_pcie_resume(struct device *dev)
 	pcie_reg_load(base, &i, 0xf80,  3);
 	iounmap(base);
 
+	}
 }
 EXPORT_SYMBOL(lm2_pcie_resume);
 
@@ -1690,7 +1505,6 @@ static int __init pcie_init(void)
 #endif
 	hook_fault_code(16 + 6, synopsys_pcie_abort, SIGBUS, 0, "imprecise external abort");
 
-//	platform_driver_probe(&synopsys_pcie_driver, synopsys_pcie_probe);
 	platform_driver_register(&synopsys_pcie_driver);
 #ifdef	DEBUG_TRACE
 	printk(KERN_ERR "pcie_init: End\n");
diff --git a/drivers/pci/pcie/synopsys_pcie.h b/drivers/pci/pcie/synopsys_pcie.h
index f017239..bd32908 100644
--- a/drivers/pci/pcie/synopsys_pcie.h
+++ b/drivers/pci/pcie/synopsys_pcie.h
@@ -212,15 +212,9 @@
 #define PCIE3_PMEM_BASE_U		0x00001000
 #define PCIE3_PMEM_LIMIT_U		0x000022FF
 
-#define	PCIE_INT_EN			0x0000005C
-#define	PCIE_PCIE1_INT_EN		0x00000060
-#define	PCIE_INT_GDA_PAB		0x00000001
-
-//#define	PCIE_PAB_AXI_INT_MISC_EN	0x00000bec
 #define	PCIE_AXI_INT_INTA		0x00000020
 
 #define	PCIE_PAB_AXI_INT_MISC_STAT	0x00000c00	/* Clear interrupt */
-#define	PCIE_PCIE1_INT_CLR		0x00000070	/* Clear PEX Interrupt */
 
 
 //--------------------------------------------------------------
@@ -265,17 +259,27 @@
 #define	PCIE2_MISC_STAT			0x0034
 #define	PCIE3_MISC_STAT			0x0038
 #define	PCIE1_MISC_CTRL			0x0020
+#define	PCIE_INT_EN			0x005c
+#define	PCIE_INT_EN__PCIETP_WRAP_rerror	0x00000001
 #define	PCIE1_INT_EN			0x0060
+#define	PCIE1_INT_EN__GDA_PAB		0x00000001
 #define	PCIE2_INT_EN			0x0064
 #define	PCIE3_INT_EN			0x0068
+#define	PCIE_INT_CLR			0x006c
+#define	PCIE_INT_CLR__PCIETP_WRAP	0x00000001
 #define	PCIE1_INT_CLR			0x0070
+#define	PCIE1_INT_CLR__PERST_N_PIN	0x00000020
+#define PCIE1_INT_CLR__GDA_PAB		0x00000001
 #define	PCIE2_INT_CLR			0x0074
 #define	PCIE3_INT_CLR			0x0078
 // PCIe Gen3 Controllers registers
 #define	PCIE_GPEXD_CORE_CLK_RATIO	0x0440
 #define	PCIE_PAB_CTRL			0x0808
 #define	PCIE_PAB_AXI_PIO_CTRL0		0x0844
+#define	PCIE1_PAB_AXI_PIO_STAT0		0x0848
+#define	PCIE1_PAB_PEX_INT_STAT		0x0ba8
 #define	PCIE_PAB_AXI_INT_MISC_EN	0x0BEC
+#define	PCIE1_PAB_PEX_INT_EN		0x0ba4
 #define	PCIE_PAB_AXI_AMAP_CTRL0		0x0CA4
 #define	PCIE_PAB_AXI_AMAP_AXI_BASE0	0x0CA8
 #define	PCIE_PAB_AXI_AMAP_PEX_BASEL0	0x0CAC
@@ -349,6 +353,7 @@
 #define	PCIE_PHY_RST_CTRL__PIPE1_RESET_N__INV_MASK	0xfffffffd
 #define	PCIE_PHY_RST_CTRL__PIPE2_RESET_N__MASK		0x00000004
 #define	PCIE_PHY_RST_CTRL__PIPE2_RESET_N__INV_MASK	0xfffffffb
+#define	PCIE1_SW_RST__PERST_N__MASK			0x00000020
 #define	PCIE1_SW_RST__PAB_N__MASK			0x00000008
 #define	PCIE1_SW_RST__PAB_N__INV_MASK			0xfffffff7
 #define	PCIE1_SW_RST__AMBA_N__MASK			0x00000004
@@ -383,7 +388,9 @@
 #define	PCIE_SW_BOOTSTRAP__PIPE_PORT_SEL__SHIFT		0
 #define	PCIE_PHY_CLK_CTRL__PHY_REF_USE_PAD__MASK	0x00000200
 #define	PCIE_PHY_PIPE_CTRL__MAC0_PCLKREQ_N__INV_MASK	0xfffcffff
+#define	PCIE_PHY_PIPE_CTRL__MAC1_PCLKREQ		0x000c0000
 #define	PCIE_PHY_PIPE_CTRL__MAC1_PCLKREQ_N__INV_MASK	0xfff3ffff
+#define	PCIE_PHY_PIPE_CTRL__MAC2_PCLKREQ		0x00300000
 #define	PCIE_PHY_PIPE_STAT__PIPE0_PHYSTATUS__MASK	0x00000001
 #define	PCIE_PHY_PIPE_STAT__PIPE1_PHYSTATUS__MASK	0x00000002
 #define	PCIE_PHY_PIPE_STAT__PIPE2_PHYSTATUS__MASK	0x00000004
@@ -396,8 +403,6 @@
 #define	PCIE2_INT_EN__GDA_PAB__MASK			0x00000001
 #define	PCIE3_INT_EN__PERST_N_PIN__MASK			0x00000020
 #define	PCIE3_INT_EN__GDA_PAB__MASK			0x00000001
-#define	PCIE1_INT_CLR__PERST_N_PIN__MASK		0x00000020
-#define	PCIE1_INT_CLR__GDA_PAB__MASK			0x00000001
 #define	PCIE2_INT_CLR__PERST_N_PIN__MASK		0x00000020
 #define	PCIE2_INT_CLR__GDA_PAB__MASK			0x00000001
 #define	PCIE3_INT_CLR__PERST_N_PIN__MASK		0x00000020
-- 
1.7.1

